# -*- coding: utf-8 -*-
"""route_optimiser_app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19W5bN73mFsBCZseZS6s3XHBIfH7Hn0X_
"""

import streamlit as st
import numpy as np
from geopy.distance import geodesic
from typing import List, Dict, Tuple, Optional
import time

Order = Dict[str, any]
Vehicle = Dict[str, any]
np.random.seed(42)
weights = np.random.rand(11)
alpha = 0.01
delta = 0.001
beta = np.array([0.5, 0.3, 0.2])


# --- Sidebar Configuration ---
st.sidebar.title("⚙️ Simulation Setup")

num_orders = st.sidebar.slider("Number of Orders", 1, 10, 5)
num_vehicles = st.sidebar.slider("Number of Vehicles", 1, 5, 2)

DEPOT_LOCATION = (12.9716, 77.5946)
st.sidebar.markdown(f"📍 Depot Location: `{DEPOT_LOCATION}`")

st.sidebar.markdown("---")
st.sidebar.markdown("ℹ️ Default values are randomized within bounds. You can regenerate manually.")

# Generate customizable orders
orders = []
for i in range(num_orders):
    with st.sidebar.expander(f"📦 Order {i+1}"):
        lat = st.slider(f"Lat {i+1}", 12.90, 12.98, round(12.91 + 0.01 * i, 5), key=f"olat_{i}")
        lon = st.slider(f"Lon {i+1}", 77.59, 77.65, round(77.60 + 0.01 * i, 5), key=f"olon_{i}")
        volume = st.number_input(f"Volume {i+1}", 1, 20, 5, key=f"ovol_{i}")
        priority = st.selectbox(f"Priority {i+1}", [0, 1], key=f"opri_{i}")
        wait_time = st.slider(f"Wait Time {i+1} (min)", 1, 10, 5, key=f"owait_{i}")
    orders.append({
        "id": f"O{i+1}",
        "location": (lat, lon),
        "priority": priority,
        "volume": volume,
        "wait_time": wait_time,
    })

# Generate customizable vehicles
vehicles = []
for i in range(num_vehicles):
    with st.sidebar.expander(f"🚛 Vehicle {i+1}"):
        lat = st.slider(f"Lat V{i+1}", 12.90, 12.98, round(12.91 + 0.005 * i, 5), key=f"vlat_{i}")
        lon = st.slider(f"Lon V{i+1}", 77.59, 77.65, round(77.60 + 0.005 * i, 5), key=f"vlon_{i}")
        capacity = st.number_input(f"Capacity V{i+1}", 10, 50, 20, key=f"vcap_{i}")
        max_wait = st.slider(f"Max Wait Time V{i+1}", 5, 30, 15, key=f"vwait_{i}")
    vehicles.append({
        "id": f"V{i+1}",
        "location": (lat, lon),
        "capacity": capacity,
        "assigned_orders": [],
        "route": [],
        "max_wait_time": max_wait,
    })

# ------------------- FUNCTIONS ----------------------

def distance(loc1: Tuple[float, float], loc2: Tuple[float, float]) -> float:
    return geodesic(loc1, loc2).km

def order_priority_score(order: Order, w: np.ndarray) -> float:
    return w[0] * order['wait_time'] + w[1] * order['priority'] + w[9] * order['volume']

def vehicle_utilization(vehicle: Vehicle) -> float:
    used = sum([o['volume'] for o in orders if o['id'] in vehicle['assigned_orders']])
    return used / vehicle['capacity'] if vehicle['capacity'] > 0 else 0.0

def vehicle_priority_score(vehicle: Vehicle, w: np.ndarray) -> float:
    utilization = vehicle_utilization(vehicle)
    pending = max(0, 3 - len(vehicle['assigned_orders']))
    return w[2] * utilization - w[3] * pending

def impact_score(order: Order, vehicle: Vehicle, w: np.ndarray) -> float:
    travel_cost = distance(order['location'], vehicle['location'])
    delay = travel_cost / VEHICLE_SPEED * 60  # in minutes
    utilization = vehicle_utilization(vehicle)
    vacant_ratio = 1 - utilization
    return w[4] * travel_cost + w[5] * delay + w[6] * vacant_ratio

def calculate_cost() -> float:
    vacant_total = sum([v['capacity'] for v in vehicles])
    distance_total = 0.0
    pending_total = 0
    for vehicle in vehicles:
        for oid in vehicle['assigned_orders']:
            o = next((x for x in orders if x['id'] == oid), None)
            if o:
                distance_total += distance(o['location'], vehicle['location'])
        pending_total += max(0, 3 - len(vehicle['assigned_orders']))
    return beta[0] * vacant_total + beta[1] * distance_total + beta[2] * pending_total

def tsp_route(vehicle: Vehicle) -> List[str]:
    return [
        order['id']
        for order in sorted(
            [order for order in orders if order['id'] in vehicle['assigned_orders']],
            key=lambda o: distance(vehicle['location'], o['location'])
        )
    ]

def assign_order_streaming(order: Order, weights: np.ndarray) -> Optional[str]:
    best_score = -np.inf
    best_vehicle = None
    for vehicle in vehicles:
        if order['volume'] > vehicle['capacity']:
            continue
        o_score = order_priority_score(order, weights)
        v_score = vehicle_priority_score(vehicle, weights)
        i_score = impact_score(order, vehicle, weights)
        total_score = o_score + v_score - i_score
        if total_score > best_score:
            best_score = total_score
            best_vehicle = vehicle
    if best_vehicle:
        best_vehicle['assigned_orders'].append(order['id'])
        best_vehicle['capacity'] -= order['volume']
        best_vehicle['route'] = tsp_route(best_vehicle)
        return best_vehicle['id']
    else:
        return None

# ------------------- STREAMLIT APP ----------------------

st.title("🚚 Dynamic VRP Assignment")
st.caption("Streaming order-to-vehicle allocation with cost-based learning")

col1, col2, col3 = st.columns(3)
col1.metric("🚐 Total Vehicles", len(vehicles))
col2.metric("📦 Total Orders", len(orders))
col3.metric("🧠 Weight Dimensions", len(weights))

st.divider()
placeholder = st.empty()

for order in orders:
    with st.spinner(f"Assigning Order {order['id']}..."):
        base_cost = calculate_cost()
        assigned_vehicle = assign_order_streaming(order, weights)

        if not assigned_vehicle:
            st.error(f"❌ Order {order['id']} could not be assigned.")
            continue

        new_cost = calculate_cost()
        delta_cost = new_cost - base_cost

        for i in range(len(weights)):
            perturbed = weights.copy()
            perturbed[i] += delta
            assign_order_streaming(order, perturbed)
            alt_cost = calculate_cost()
            gradient = alt_cost - new_cost
            if gradient > 0:
                weights[i] -= alpha * abs(gradient)
            elif gradient < 0:
                weights[i] += alpha * abs(gradient)
            for v in vehicles:
                if order['id'] in v['assigned_orders']:
                    v['assigned_orders'].remove(order['id'])
                    v['capacity'] += order['volume']

        final_vehicle = assign_order_streaming(order, weights)
        st.success(f"✅ Order {order['id']} assigned to Vehicle {final_vehicle}")
        st.write(f"💸 Cost Impact: `{delta_cost:.2f}` | 📈 Updated Weights: `{weights[:3]}` ...")
        st.progress(min(100, int((new_cost / 100) * 100)))
        time.sleep(1.2)

# ------------------- FINAL OUTPUT ----------------------

st.subheader("📊 Final Vehicle Status")

for v in vehicles:
    with st.expander(f"🚛 Vehicle {v['id']} Summary", expanded=True):
        st.write(f"**Remaining Capacity**: {v['capacity']}")
        st.write(f"**Assigned Orders**: {v['assigned_orders']}")
        st.write(f"**Optimized Route**: {v['route']}")

st.divider()
st.subheader("🧠 Final Learned Weights")
st.json({f"w[{i}]": round(w, 3) for i, w in enumerate(weights)})

