# -*- coding: utf-8 -*-
"""route_optimiser_app

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/19W5bN73mFsBCZseZS6s3XHBIfH7Hn0X_
"""

import streamlit as st
import numpy as np
import random
from geopy.distance import geodesic
from typing import List, Dict, Tuple, Optional

# ---------------------- TYPE DEFINITIONS ---------------------- #
Order = Dict[str, any]
Vehicle = Dict[str, any]

# ---------------------- HELPER FUNCTIONS ---------------------- #
def distance(loc1: Tuple[float, float], loc2: Tuple[float, float]) -> float:
    return geodesic(loc1, loc2).km


def generate_orders(n: int) -> List[Order]:
    return [{
        "id": f"O{i+1}",
        "location": (
            round(random.uniform(12.90, 12.98), 5),
            round(random.uniform(77.59, 77.64), 5)
        ),
        "priority": random.choice([0, 1]),
        "volume": random.randint(3, max_order_volume),
        "weight": random.randint(5, max_order_weight),
        "wait_time": random.randint(min_wait_time, max_wait_time)
    } for i in range(n)]


def generate_vehicles(n: int) -> List[Vehicle]:
    return [{
        "id": f"V{i+1}",
        "location": (
            round(random.uniform(12.90, 12.98), 5),
            round(random.uniform(77.59, 77.64), 5)
        ),
        "capacity": random.randint(*vehicle_capacity_range),
        "weight_limit": random.randint(*vehicle_weight_range),
        "assigned_orders": [],
        "route": [],
        "max_wait_time": 15
    } for i in range(n)]


def vehicle_utilization(vehicle: Vehicle) -> float:
    used_volume = sum([order_map[o]['volume'] for o in vehicle['assigned_orders'] if o in order_map])
    return used_volume / vehicle['capacity'] if vehicle['capacity'] > 0 else 0.0


def order_priority_score(order: Order, w: np.ndarray) -> float:
    return w[0]*order['wait_time'] + w[1]*order['priority'] + w[9]*order['volume'] + w[10]*order['weight']


def vehicle_priority_score(vehicle: Vehicle, w: np.ndarray) -> float:
    utilization = vehicle_utilization(vehicle)
    pending = max(0, 3 - len(vehicle['assigned_orders']))
    return w[2]*utilization - w[3]*pending


def impact_score(order: Order, vehicle: Vehicle, w: np.ndarray) -> float:
    travel_cost = distance(order['location'], vehicle['location'])
    delay = travel_cost / vehicle_speed * 60
    utilization = vehicle_utilization(vehicle)
    vacant_ratio = 1 - utilization
    return w[4]*travel_cost + w[5]*delay + w[6]*vacant_ratio


def calculate_cost() -> float:
    vacant_total = sum([v['capacity'] for v in vehicles])
    distance_total = sum([
        distance(order_map[o]['location'], v['location'])
        for v in vehicles for o in v['assigned_orders'] if o in order_map
    ])
    pending_total = sum([max(0, 3 - len(v['assigned_orders'])) for v in vehicles])
    return beta[0]*vacant_total + beta[1]*distance_total + beta[2]*pending_total


def insert_time_priority_order(vehicle: Vehicle, order: Order) -> List[str]:
    if not vehicle['assigned_orders']:
        return [order['id']]

    current_route = vehicle['assigned_orders'].copy()
    best_position = None
    min_violation = float('inf')

    for i in range(len(current_route) + 1):
        new_route = current_route[:i] + [order['id']] + current_route[i:]
        total_time = 0
        prev_loc = depot_location

        for oid in new_route:
            o = order_map[oid]
            dist = distance(prev_loc, o['location'])
            total_time += (dist / vehicle_speed) * 60
            if oid == order['id']:
                break
            prev_loc = o['location']

        wait_violation = total_time - order['wait_time']
        if wait_violation <= 0:
            return new_route
        elif wait_violation < min_violation:
            min_violation = wait_violation
            best_position = new_route

    return best_position


def assign_order_streaming(order: Order, weights: np.ndarray) -> Optional[str]:
    best_score = -np.inf
    best_vehicle = None
    best_route = None

    for vehicle in vehicles:
        if order['volume'] > vehicle['capacity'] or order['weight'] > vehicle['weight_limit']:
            continue

        o_score = order_priority_score(order, weights)
        v_score = vehicle_priority_score(vehicle, weights)
        i_score = impact_score(order, vehicle, weights)
        total_score = o_score + v_score - i_score

        if total_score > best_score:
            best_score = total_score
            best_vehicle = vehicle
            best_route = (
                insert_time_priority_order(vehicle, order)
                if order['priority'] == 1 else vehicle['assigned_orders'] + [order['id']]
            )

    if best_vehicle:
        best_vehicle['assigned_orders'].append(order['id'])
        best_vehicle['capacity'] -= order['volume']
        best_vehicle['weight_limit'] -= order['weight']
        best_vehicle['route'] = best_route
        return best_vehicle['id']
    return None

# ---------------------- STREAMLIT UI ---------------------- #
st.title("ðŸšš Dynamic VRP with Time & Standard Order Assignment")

with st.sidebar:
    st.header("Simulation Parameters")
    num_orders = st.slider("Number of Orders", 1, 30, 10)
    num_vehicles = st.slider("Number of Vehicles", 1, 10, 4)
    vehicle_speed = st.slider("Vehicle Speed (km/h)", 10, 60, 30)
    max_order_volume = st.slider("Max Order Volume", 5, 30, 10)
    max_order_weight = st.slider("Max Order Weight", 10, 50, 20)
    min_wait_time = st.slider("Min Wait Time (min)", 1, 10, 2)
    max_wait_time = st.slider("Max Wait Time (min)", 5, 30, 6)
    vehicle_capacity_range = st.slider("Vehicle Capacity Range", 10, 100, (20, 35))
    vehicle_weight_range = st.slider("Vehicle Weight Limit", 50, 200, (50, 100))
    run_simulation = st.button("ðŸš€ Run Streaming Assignment")

# ---------------------- MAIN LOGIC ---------------------- #
if run_simulation:
    depot_location = (12.9716, 77.5946)
    beta = np.array([0.5, 0.3, 0.2])
    weights = np.random.rand(11)
    ALPHA = 0.01
    DELTA = 0.001

    orders = generate_orders(num_orders)
    vehicles = generate_vehicles(num_vehicles)
    order_map = {o['id']: o for o in orders}

    st.subheader("ðŸ“¦ Streaming Assignments")
    for order in orders:
        base_cost = calculate_cost()
        assigned_vehicle = assign_order_streaming(order, weights)

        if not assigned_vehicle:
            st.error(f"âŒ Order {order['id']} could not be assigned.")
            continue

        new_cost = calculate_cost()
        delta_cost = new_cost - base_cost

        for i in range(len(weights)):
            perturbed = weights.copy()
            perturbed[i] += DELTA
            assign_order_streaming(order, perturbed)
            alt_cost = calculate_cost()
            gradient = alt_cost - new_cost

            if gradient > 0:
                weights[i] -= ALPHA * abs(gradient)
            elif gradient < 0:
                weights[i] += ALPHA * abs(gradient)

            # Revert assignment
            for v in vehicles:
                if order['id'] in v['assigned_orders']:
                    v['assigned_orders'].remove(order['id'])
                    v['capacity'] += order['volume']
                    v['weight_limit'] += order['weight']

        assign_order_streaming(order, weights)
        st.success(f"âœ… Order {order['id']} assigned to {assigned_vehicle} | Cost: {new_cost:.2f}")

    st.subheader("ðŸ“Š Final Vehicle Assignments")
    for v in vehicles:
        st.write(f"**{v['id']}** âž¤ Orders: {v['assigned_orders']} âž¤ Route: {v['route']}")

    st.subheader("ðŸ“ˆ Final Weights")
    st.code(weights)

